NB. tte.ijs
NB. TTE (Tacit-To-Explicit) - an explicator for tacit verbs
NB. HAND-UPDATED: Thursday, 19 September 2013  07:22:23

coclass 'tte'
require 'strings'

NB. ========== STARTER VERB ==========

start=: 3 : 0
	NB. executed once script has been loaded
'TTELOC_z_' default 'base'	NB. default the source locale
gensym 0	NB. initialize the symbol-counter
TEST''		NB. create some test-data (COMMENT-OUT IF NOT WANTED)
	NB. SETUP USER-ADJUSTABLE PARAMETERS HERE ...
COPULA=: '=.'
COPULA=: '=:'
DECOMPOSE=: 1			NB. Boolean: 1 - separate: u@v u&v
NOCOMMENT=: 0			NB. Boolean: 1 - suppress line-comments
PREFIX=: ;:'tsrqpz ab cde uvw'	NB. 4-atom list of boxed strings
PREVERB=: 'smoutput'
PREVERB=: ''
PREVERB=: ']'
i.0 0
)

NB. ========== DOCUMENTATION NOUNS ==========

ABTIME=: '2012-10-22  20:40:00'

ABOUT=: 0 : 0
based on: jsoftware.com/jwiki/Scripts/TacitToExplicit
written by Ian Clark (2012)
 from an original script (tte.ijs) by Zsban Ambrus.
-
Explicates a tacit verb u (the "explicand").
The result is the "explication" of u -
 an explicit definition behaving like the original verb: u.
Each sentence computes an intermediate result from a phrase
 of (tacit) u, usually a noun but sometimes a verb.
This is assigned to a pronoun (proverb) generated by verb: gensym.
EXAMPLE:
   mean=: +/ % #	NB. a sample "explicand"
   require 'debug/tte'
   mean tte
3 : 0
    NB. +/ % #
] s0=: # y	NB. simple: #
] t0=: +/ y	NB. (main)h: ,'/'
] r0=: t0 % s0	NB. simple: %
		NB. fork: +/ % #
:
] s0=: x # y	NB. simple: #
] t0=: x +/ y	NB. (main)h: ,'/'
] r0=: t0 % s0	NB. simple: %
		NB. fork: +/ % #
<RIGHT-PARENTHESIS>
NOTES:
1. The explication is a verb, not a text array of code.
   This allows tte to be used flexibly like so:
    u tte	NB. outputs the explication
    uX=: u tte	NB. makes verb uX which behaves like u.
2. Monadic and dyadic parts are always provided,
   even if one of these is unwanted or meaningless
   (as is the case with dyadic: mean).
3. Intermediate results by default are saved like so:
	] s0=: # y
not like so:
	s0=. # y
to facilitate line-by-line execution of the explication
 with sample x and y, and inspection of intermediate
 values after a sample run.
This behaviour can be changed by assigning new values
 to COPULA_tte_ and PREVERB_tte_ (see below).
The default behaviour emphasises that tte is not meant
 for generating operational explicit verb definitions,
 but to help a beginner understand how a given tacit
 verb works.
-
Loading this script creates...
	- an adverb: tte_z_
	- a locale: _tte_ which implements: tte_z_
Adverb: tte_z_ remembers the "source locale", ie
 the current locale at call-time, saved in: TTELOC_z_
It needs this in order to identify any name it finds
 nested in the explicand's Atomic Representation (AR),
 especially to discover its type (noun, verb, etc)
 and to "de-reference" the explicand: u in its proper
 environment (See verb: deref).
-
The heart of the algorithm is the verb: main. 
This recursively analyses the Atomic Representation (AR)
 of the explicand: u
Verb: main - calls the appropriate choice of Expander.
(See verb: deflt for the basic format of an Expander.)
Each Expander is a dyad, taking args: x y ...
	y - the AR of explicand u, or a nested AR within it.
	x - boxed args: the nouns acted-on by explicand u.
Typically x is either of two globals: XY or NY
	XY (-: ;:'x y') for dyadic call of: u
	NY (-: ;:'y')  for monadic call of: u
but if y is an AR nested in the AR of explicand u, then
 x will name the work vars containing intermediate results.
Each Expander returns a list of boxed (J) sentences.
Verb: main returns a combined list of boxed sentences
 resulting from verb: main being called recursively by
 the Expanders which main itself calls.
 When opened, this boxed list forms part of the explication.
Adverb: tteT calls conjunction: cum twice to make the 2 parts
 of the explication: <monadic> : <dyadic> .
 The 'u' and 'v' of cum when called by tteT are:
	u - the 'u' of tte itself
	v - either mmain (NY&main) or dmain (XY&main)
Verb: mmain makes the monadic part, dmain the dyadic part,
 of the completed explication.
-
Note these user-alterable nouns in locale _tte_ ...
  COPULA	Copula to be used in the explication.
			Can be: '=:' or: '=.'

  NOCOMMENT	Boolean: 1 - suppress line-comments.

  PREVERB	Optional prefix verb for each sentence,
			Suggest: ']' or: 'smoutput' or: ''

  PREFIX	4-atom boxed stringlist - 1st-letters of names for:
			>0{PREFIX - nouns
			>1{PREFIX - adverbs
			>2{PREFIX - conjunctions
			>3{PREFIX - verbs

  DECOMPOSE	Boolean: separate @ and & phrases?
			1 - split u@v into separate sentences
			0 - keep u@v together in 1 sentence.
)

0 : 0
cocurrent'base'
cocurrent 'tte'
	NB. Covering a verb in _tte_ ...
lw 'cover'		NB. load the verb-coverer
cover 'fork'
un cover 'fork'		NB. uncover it again
coverZ=: ''		NB. reset the arg record
	NB. Analysis of a long tacit sentence
spiral1=: - ]\ >:@:i.@:*: [`]`[} [: /: [: ,/ [: (>.&| , (12&o.)@:(1j_1&*)@:j.)"0/~ i. - -:@:<:
spiral1 5		NB. 5 by 5 spiral array
NB. Split spiral1 into two verbs: sh and sp (calling sh) ...
NB.  - ]\ >:@:i.@:*: [`]`[} [: /: [: ,/ [: (>.&| , (12&o.)@:(1j_1&*)@:j.)"0/~ i. - -:@:<:
sh=:                                        >.&| , (12&o.)@:(1j_1&*)@:j.   
sp=: - ]\ >:@:i.@:*: [`]`[} [: /: [: ,/ [: (  sh                        )"0/~ i. - -:@:<:
sp 5			NB. check it works
NB. now explicate sh and spx (from sp by substituting shX for sh)
shX=: sh tte
shX			NB. explicit expansion of the sh component of: spiral1
spx=: - ]\ >:@:i.@:*: [`]`[} [: /: [: ,/ [: shX"0/~ i. - -:@:<:
spx 5			NB. check it works
spX=: spx tte
spX			NB. explicit expansion of: spiral1 -with shX embedded
spX 5			NB. check it works
	NB. nub mean meancat (see: ONLOAD above) ...
nub tte		NB. =====================================
meancat tte	NB. =====================================
meancat1 tte	NB. =====================================
	NB. trains & compositions ...
vb=: (d@((a b c)"1))
]y=: 5!:1 <'vb'
vb tte	NB. =====================================
XY simple yleaf
NY simple yleaf
XY simple ylev
NY simple ylev
XY simple ydex
NY simple ydex
)

NB. ========== MORE NOUNS ==========

SEPARATOR=: <':'
NB=: 'NB.'
NY=: ;:'y'
XY=: ;:'x y'
UNSET=: '<UNSET>'

BL=: '['
BR=: ']'
CM=: ','
CO=: ':'
PL=: '('
PR=: ')'
QQ=: '"'
QT=: ''''
SL=: '/'
SP=: ' '
UL=: '_'

NB. ========== ADVERBS ==========

toAR=: 1 : 0
	NB. adverb: (verb: u) --> AR
5!:1<'u'
)

ftoAR=: 1 : 0
	NB. adverb: (verb: u f.) --> AR
	NB. c/f: toAR
vb=. u f.
5!:1<'vb'
)

toV=: 5!:0	NB. adverb: AR --> verb

tte_z_=: 1 : 0
	NB. adverb: (tacit verb) --> (explicit verb)
	NB. This is the main user-interface to TTE
	NB. WARNING: This definition MUST reside in _z_
TTELOC_z_=: >coname''
u tteT_tte_
)

tteT=: 1 : 0
	NB. adverb: returns an explicitly-defined ambivalent verb
	NB. which behaves like the given verb: u
	NB. 	u - the "explicand" (tacit verb to be explicated)
	NB. 	ret'd - the "explication" (3 : <sentences>)
ttea=: deref 5!:1<'u'	NB. Atomic Repn of: u
	NB. (=:) to make ttea available for later inspection
if. IsExplicit ttea do.	'explicit definition'	error 101 end.
if. IsNoun ttea do.	'is a noun'		error 102 end.
if. -. IsVerb ttea do.	'not a verb'		error 103 end.
	NB. If u is the verb: (?) then treat as status request ...
if. ttea-:(? toAR) do. status'' return. end.
	NB. Generate the header, describing: u
tteL=. 5!:5<'u'		NB. Linear Repn of: u
try.
  ttel=. linear ttea	NB. Linear Repn of de-referenced: u
  if. ttel-:tteL do. tteh=. <TAB,NB,SP,ttel
  else.              tteh=. <TAB,NB,SP,(paren tteL),CO,SP,ttel
  end.
catch.
  tteh=. <TAB,NB,SP,(paren tteL),CO,SP,'??'
end.
	NB. Generate the sentences of the explication
gensym 0		NB. init symbol count
m=. u cum mmain		NB. monad sentences
gensym 0		NB. init symbol count
d=. u cum dmain		NB. dyad sentences
	NB. Return the explication as a verb
3 : (tteh , m , SEPARATOR , d)
)

ttry_z_=: 1 : 0
	NB. try tacit verb u and its explication with x and y
	NB. test with: open temp 907
UNSET_tte_ (u ttry) y
:
T=: u f.		NB. compiled tacit u
U=: u f. tte		NB. explication of u
L=: 5!:6<'u'		NB. paren rep of u
LT=: 5!:6<'T'		NB. paren rep of T
LU=: 5!:6<'U'		NB. paren rep of U
ZT=: ZU=: UNSET_tte_
va=. 'dyad' [ xq=. 'X'
if. x-:UNSET_tte_ do. va=. 'monad' [ xq=. ' ' end.
smoutput ' ',xq,' (',LT,') ttry Y',TAB,TAB,'NB.',va,(5>:+/LU=LF)#':SHORT'
if. x-:UNSET_tte_ do.
  ZT=: (T ::errort_tte_) y	NB. check tacit works with y
  ZU=: (U ::errorx_tte_) y	NB. check explicit works with y
else.
  ZT=: x (T ::errort_tte_) y	NB. check tacit works with y and x
  ZU=: x (U ::errorx_tte_) y	NB. check explicit works with y and x
end.
if. -. ZT -: ZU do.
  smoutput ' ZU ...'
  smoutput ZU
  smoutput ' ZT ...'
  smoutput ZT
  'ZU-:ZT failure' error_tte_ 105
end.
ZT
)

NB. ========== CONJUNCTIONS ==========

cum=: 2 : 0
	NB. conjunction to build interface adverbs
	NB. u - explicand
	NB. v - mmain or dmain
pfx fixup v deref 5!:1<'u'
)

NB. ========== VERBS ==========

TEST=: 3 : 0
	NB. Create test data for Expander-verbs
	NB. sample AR's which define nouns ...
]yn0=: 0 toAR
]yn99=: 99 toAR
]yi23=: (i.2 3) toAR
	NB. sample AR's which define verbs ...
]ylev=: [ toAR
]ydex=: ] toAR
]yleaf=: (ux) toAR
]ytild=: (ux~) toAR
]yhook=: (ux vx) toAR
]yfork=: (ux vx wx) toAR
]yhf=: ((ux vx wx)(uu vv ww)) toAR
]yatop=: (ux@vx) toAR
]ybond=: (ux&vx) toAR
]yat=: (ux@:vx) toAR
]yap=: (ux&:vx) toAR
]ycap=: ([: ux vx) toAR
]yaf=: (ux@(uu vv ww)) toAR
]yfaf=: ((ux vx wx)@(uu vv ww)) toAR
]ybf=: (ux&(uu vv ww)) toAR
]yfbf=: ((ux vx wx)&(uu vv ww)) toAR
]yatf=: (ux@:(uu vv ww)) toAR
]yfatf=: ((ux vx wx)@:(uu vv ww)) toAR
]yapf=: (ux&:(uu vv ww)) toAR
]yfapf=: ((ux vx wx)&:(uu vv ww)) toAR
]ycapf=: ([: (ux vx wx)(uu vv ww)) toAR
]yda=: (d@((ux vx wx)"1)) toAR
	NB. Create common test tacit verbs in _z_
	NB. ...test these verbs with y=:i.2 3 or y=:i.2 3 4
nub_z_=: (i.@:# = i.~) # ]
mean_z_=: +/ % #
cat_z_=: ,&1"1
meancat_z_=: mean@cat
meancat1_z_=: mean@:cat
i.0 0
)

Expander=: 4 : 0
	NB. Identifies an Expander-verb
	NB. Called like so: 'xX xY AL AM AR'=. x Expander y
	NB. validates y and separates into worknouns
	NB. x - name of calling Expander-verb
	NB. y - y-arg of calling verb (always an AR)
	NB. UNLESS it is a leaf, eg: <'mean' or: <,'a'
	NB. -an AR is always of form: (H;K)
	NB.	H is the header/identification tag of the AR (always string)
	NB.	(>K) is list of child AR's: (AL,AM,AR)
	NB. NOTE: For diagnostic convenience -
	NB.  xX xY AL AM AR H K are saved as globals here, using '=:'
	NB.  but there is no operational need for this.
smoutput=. empty	NB. no diagnostic output (COMMENT-OUT IF REQD)
'xX xY'=: _2{.x		NB. xX-:'' iff x has only the xY component
if. IsLeaf y do.
  H=: ''
  AL=: y
  AM=: AR=: a:
  K=: AL,AM,AR
else.
  H=: ,>{.>y
  K=: ,>{:>y
  AL=: {.K
  AM=: {.}.K		NB. AM-: a: if (1{K) is absent
  AR=: {:K		NB. AR-: AL if (2{K) is absent
end.
smoutput 'H: ' , crex H
smoutput AL [ smoutput 'AL:',brack $AL
smoutput AM [ smoutput 'AM:',brack $AM
smoutput AR [ smoutput 'AR:',brack $AR
xX;xY;AL;AM;<AR
)

IsCap=: '[:' -: [: , >
IsDefined=: 0 <: [: 4!:0 <
IsDyad=: 2 = #

IsExplicit=: 3 : 0
	NB. 1 iff y is AR of an explicit verb
if.-. (<,':') -: {. >y do. 0 return. end.
if. 3 4 e.~ >{:>{.>{:>y do. 1 return. end.
0
)

IsGets=: 3 : 0
	NB. =1 iff y is an assignment
	NB. y is boxed or open string
1 e. ('=:' E. >y),('=.' E. >y)
)

IsInf=: [: *./ _ = ]
IsLeaf=: 1 >: L.
IsMonad=: 1 = #

IsName=: 3 : 0
	NB. recognise (y) or (>y) as a valid J name
_1 <: 4!:0 <,> y
)

IsNameX=: 3 : 0
	NB. >>>>>>>>>>> CHECK IF UNUSED <<<<<<<<<<<<<<<<<
	NB. recognise (y) or (>y) as a valid J name
	NB. but discount names: 'x' and 'y'
y=. <,> y
if. y-: <,'y' do. 0 return. end.
if. y-: <,'x' do. 0 return. end.
_1 <: 4!:0 y
)

IsNoun=: 3 : 0
	NB. =1 iff (AR) y defines a noun IN LOCALE: TTELOC
cocurrent TTELOC
tte_z=. y 5!:0
0 = 4!:0<'tte_z'
)

IsVerb=: 3 : 0
	NB. =1 iff (AR) y defines a verb IN LOCALE: TTELOC
cocurrent TTELOC
tte_z=. y 5!:0
3 = 4!:0<'tte_z'
)

TheConst=: 3 : 0
	NB. the integer value of 0: 1: ...
	NB. if not one of these, returns 0$0
if. 1~:L.y		do. 0$0 return. end.
if. -. ':'-:{:>y	do. 0$0 return. end.
z=. }:>y	NB. z must be a string
if.-. 1 2 e.~ #z	do. 0$0 return. end.
n=. 11".z
if.-. n e. __ _,i:9	do. 0$0 else. n end.
)

all=: *./
any=: +./
and=: *.
or=: +.

appose=: 4 : 0
	NB. derived from: atco
NB. >XY appose yap [ gensym''
NB. >XY appose yapf [ gensym''
NB. >XY appose yfapf [ gensym''
'xX xY AL AM AR'=. x Expander y
expr=. 'appose: ',linear y
NB. atco:	Appose	(&:)	Monad:   u&:v y <--> u v y
NB. appose:	Appose	(&:)	 Dyad: x u&:v y <--> (v x) u (v y)
if. IsMonad x do. x atco y return. end.
	NB. WHAT REMAINS IS THE DYAD CASE ...
's a'=. toname (xmake xX) main AR	NB. symbol and assignments for AR [v x]
't b'=. toname (xmake xY) main AR	NB. symbol and assignments for AR [v y]
c=. (s xmake t) main AL			NB. symbol and assignments for AL [() u ()]
expr comment a,b,c			NB. Combine the lines
)
0 : 0
>XY appose yap [ gensym''
>XY appose yapf [ gensym''
>XY appose yfapf [ gensym''
)

atco=: 4 : 0
NB. XY atco yat
NB. XY atco yatf
NB. XY atco yfatf
'xX xY AL AM AR'=. x Expander y
expr=. 'atco: ',linear y
NB. atco:	At	(@:)	Monad:   u@:v y <--> u v y
NB. atco:	At	(@:)	 Dyad: x u@:v y <--> u x v y
b=. x main AR		NB. assignments-only for AR
NB.  IsLeaf=. 0:		NB. <<<<< DISABLE: IsLeaf LOCALLY...
if. IsLeaf AL do.
	NB. This block is functionally redundant,
	NB. but it saves a sentence in the expansion.
  leaf=. >AL		NB. this is a linear phrase for [u]
  bx=. }:b		NB. leading sentences for AR
  bz=. >{:b		NB. final line (non-assignment) for AR
  expr comment bx , <nbd leaf ; bz
else.
  't bb'=. toname b	NB. symbol(t) and assignments(bb) for AR
  a=. (<t)main AL	NB. assignments-only for AL
  expr comment bb,a	NB. Combine the sentences
end.
)
0 : 0
>XY atco yat [ gensym''
>XY atco yatf [ gensym''
>XY atco yfatf [ gensym''
)

atop=: 4 : 0
NB. NY atop yatop
NB. XY atop yaf
'xX xY AL AM AR'=. x Expander y
expr=. 'atop: ',linear y
NB. atop	Atop	(@)	Monad:   u@v y <--> u v y
NB. atop	Atop	(@)	 Dyad: x u@v y <--> u x v y
if. DECOMPOSE-:0 do. x deflt y return. end.
	NB. Else separate out verb assignments for AL and AR
's a'=. 3 toname <linear AL	NB. 3 - s is for a VERB
't b'=. 3 toname <linear AR	NB. 3 - t is for a VERB
'st c'=. toname <nbd xX ; ('<@',t) ; xY
d=. <nbd (s,'@>') ; st
expr comment a,b,c,d
)

bond=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'bond: ',linear y
NB. bond:	Bond	(&)	(only when one obj is a noun)
NB. atop	Compose	(&)	Monad:   u&v y <--> u v y
NB. compose	Compose	(&)	 Dyad: x u&v y <--> (v x) u (v y)
if. IsNoun AL do.
  ll=. parenQ linear AL
  if. 5<#ll do.
    's a'=. toname<ll
    b=. (s xmake xY) main AR
    expr comment a,b
  else.
    expr comment (ll xmake xY) main AR
  end.
elseif. IsNoun AR do.
  rr=. parenQ linear AR
  if. 5<#rr do.
    't b'=. toname<rr
    a=. (xY xmake t) main AL
    expr comment b,a
  else.
    expr comment (xY xmake rr) main AL
  end.
  NB. CAN NOW ASSUME both atoms are verbs...
elseif.  IsDyad x do.	x compose y return.
elseif. IsMonad x do.	x atop y return.
elseif.do. 'unknown valency' error 104
end.
)

brack=: BR ,~ BL , ":

comment=: 4 : 0
	NB. Append comment: x to last line of sentence-list: y
	NB. adapted from: fixup
	NB.	({:y) - last sentence in list
	NB.	(}:y) - residue sentences
if. NOCOMMENT do. y return. end.
z=. >{:y	NB. Extract and open the last sentence
if. 1 e. NB E. z do.
  z=. z,LF,TAB,TAB,NB,SP,x
else.
  z=. z,TAB,NB,SP,x
end.
(}:y),<,z	NB. sentence-list retd
)

compose=: 4 : 0
	NB. derived from: atop
NB. XY compose ybond
NB. XY compose ybf
'xX xY AL AM AR'=. x Expander y
expr=. 'compose: ',linear y
NB. atop	Compose	(&)		Monad:   u&v y <--> u v y
NB. compose	Compose	(&)		 Dyad: x u&v y <--> (v x) u (v y)
if. IsMonad x do. x atop y return. end.
	NB. WHAT REMAINS IS THE DYAD CASE ...
if. DECOMPOSE-:0 do. x deflt y return. end.
's a'=. 3 toname <linear AL	NB. 3 - s is for a VERB [u]
't b'=. 3 toname <linear AR	NB. 3 - t is for a VERB [v]
'ss c'=. 0 toname <nbd ('<@',t) ; xX		NB. [v x]
'st d'=. 0 toname <nbd ('<@',t) ; xY		NB. [v y]
'su e'=. 0 toname <nbd ss ; (s,'@>') ; st	NB. [() u ()]
expr comment a,b,c,d,e		NB. sentence-list retd
)

crex=: 3 : 0
0 crex y
:
NB. printable lit repn of (string)noun y
NB. y is VALUE. For cr-replacement use: crx
NB. x=1 reveals diagnostics otherwise hidden
z=. y rplc QT ; QT,QT
z=. q1 z rplc CRLF ; (q1',CRLF,') ; CR ; (q1',CR,') ; LF ; (q1',LF,') ; TAB ; (q1',TAB,')
NB. catch remaining non-print chars in: y
for_c. ~. y -. 32}. 127{. a. do.
  z=. z rplc c ; q1 CM, CM,~ paren (":a. i. c),'{a.'
end.
NB. eliminate: '',*  *,'' *,'',*
z=. z rplc (CM,QT,QT,CM) ; CM
if. (3{.z)-:QT,QT,CM do. z=. 3}.z end.
if. (_3{.z)-:CM,QT,QT do. z=. _3}.z end.
NB. specify ravel for vec len: 1
if. ($y)-:(,1) do. z=. CM,z end.
try. assert y -: ".z	NB. Does it convert back again?
catch.
NB.   if. x do.
NB.     smoutput '>>> crex: BAD lit repn: z --'
NB.     smoutput z
NB.     smoutput '>>> crex: --using instead: 5!:6 <''y'''
NB.   end.
  5!:6 <'y' return.	NB. use built-in conversion instead
end.
z
)

default=: 4 : 0
	NB. (Copied from j602: ~system/main/misc.ijs)
	NB.*default v set default value
	NB. name default value
	NB. set global name to value if not already defined
nc=. 4!:0 <x
if. _1=nc do. ".x,'=: y'
elseif. _2=nc do. 'invalid name: ',":,x
end.
empty''
)

deflt=: 4 : 0
	NB. The "default" Expander
	NB. generates unexpanded [x] u y - given tacit u
NB. 'xX xY AL AM AR'=. x Expander y	NB. Redundant.
expr=. 'deflt: ',linear y
expr comment x deflt0 y
)

deflt0=: 4 : 0
	NB. c/f deflt. Used as a cop-out by an Expander verb.
	NB. Leaves it to the caller to supply a comment, if any.
'xX xY AL AM AR'=. x Expander y
,<nbd xX ; (parenQ linear y) ; xY
)

deref=: 3 : 0
	NB. de-reference (AR) y in the "source locale" TTELOC
cocurrent TTELOC
if. 1<L.y do. y
elseif. 3~:4!:0 y do. y 
elseif. do. 5!:1 y
end.
)

dmain=: XY&main

error=: 3 : 0
	NB. report error and terminate
	NB. Alter this cover to report errors in a different way
	NB. y - error number
	NB. x - error message (optional)
13!:8 y
:
x 13!:8 y
)

errort=: 3 : 0
NB. 'tacit verb fails with y' ; y
'tacit verb fails with y' error 110
:
NB. 'tacit verb fails with x;y' ; x ; y
'tacit verb fails with x;y' error 111
)

errorx=: 3 : 0
NB. 'explication fails with y' ; y
'explication fails with y' error 120
:
NB. 'explication fails with x;y' ; x ; y
'explication fails with x;y' error 121
)

fixup=: 3 : 0
	NB. Turn last line of y into an assignment
	NB. y - sentence-list
	NB.	({:y) - last sentence in list
	NB.	(}:y) - residue sentences
z=. >{:y	NB. Extract and open the last sentence
if. -.IsGets z do.
  s=. 0 gensym''
  z=. s,COPULA,SP,z	NB. prefix z with an assignment
end.
(}:y),<,z	NB. sentence-list retd
)

fork=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'fork: ',6 linear y
	NB. Use: atco if y is a capped fork ...
if. IsCap AL do. x atco < '@:' ;< AM,AR return. end.
	NB. Setup symbol (s) and feed sentences (a) ...
n=: TheConst AL
if. (1=#n) and ({.n e. _ __,i:9) do.
	s=. ":n			NB. symbol s is lit numeral
	a=. 0$a:		NB. empty assignments-list
elseif. IsNoun AL do.
	s=. parenQ linear AL	NB. symbol s is noun-phrase
	a=. 0$a:		NB. empty assignments-list
elseif. do. 
	's a'=. toname x main AL
end.
't c'=. toname x main AR	NB. symbol(t) and assignments(c) for AR
b=. (s xmake t) main AM		NB. assignments-only(b) for AM
expr comment c,a,b		NB. sentence-list retd
)

gensym=: 3 : 0
symcnt=: _1	NB. Initialize symbol count
:
	NB. makes unique symbols: t0 s0 r0 q0 p0 z0 t1 ...
pfix=. >x{PREFIX
z=. symcnt=: >:symcnt
'm n'=. (0,#pfix) #:z
(n{pfix), ":m
)

hook=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'hook: ',linear y
's a'=. toname (xmake xY) main AR	NB. symbol(s) and assignment(a) for AR
if. IsDyad x do.
  b=. (xX xmake s) main AL		NB. assignments(b)-only for AL
else.
  b=. (xY xmake s) main AL		NB. assignments(b)-only for AL
end.
expr comment a,b			NB. sentence-list retd
)

inLOC=: 3 : 'if. UL={:y do. y else. y,UL,TTELOC,UL end.'

linear=: 3 : 0
5 linear y
:
	NB. linear representation of (AR) y
	NB. x is 5 (linear rep) or 6 (paren rep)
	NB. NOT GOOD at restoring numbers, or scalars, in nouns
	NB. ONLY GOOD for a visible repn in comments, etc.
cocurrent TTELOC
vn=. y 5!:0	NB. the verb/noun defined by: (AR) y
z=. 5!:x<'vn'	NB. linear repn of vn
)

main=: 4 : 0
	NB. Recursively translates 5!:1-nodes (AR's)
if. IsLeaf y do. x simple y return. end.
expr=. 'main: h-: ',crex h=. ,>{.>y
select. h	NB. h is the "identifying" tag in the AR: y
case. ,'3' do. x fork y
case. ,'2' do. x hook y
case. '@:' do. x atco y
case. '&:' do. x appose y
case. ,'@' do. x atop y
case. ,'&' do. x bond y
case. ,'"' do. x rank y
case. ,'~' do. x swap y
case. ,':' do. x mondy y
case.      do. expr comment x deflt0 y
end.
)

mmain=: NY&main

mondy=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'monad-dyad: ',linear y
if. IsDyad x do. expr comment x main AR
else.		 expr comment x main AL
end.
)

nb=: ([: }:@; (<' ') ,.~ ,.)@:(":&.>)
nbd=: dltb@nb
paren=: PR ,~ PL , ":

parenQ=: 3 : 0
	NB. conditional parentheses
	NB. avoids parentheses if judged not needed.
	NB. Add further tests as necessary...
y=. ,y
if. (y-:,'x') or (y-:,'y') do. y return. end.
if. IsName y do. y return. end.
if. QQ e. y do. paren y return. end.
if. (-.PL e. y) and (SP e. y) do. paren y return. end.
y return.
)

pfx=: 3 : '(<PREVERB,SP),each y'
q1=: QT , QT ,~ [: ": >

rank=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'rank: ',linear y
if. IsNoun AL do.
  expr comment x deflt0 y return.
elseif. -.IsNoun AR do.
  expr comment x deflt0 y return.
end.
N=. AR 5!:0	NB. the noun rep'd by AR
's a'=. 3 toname <linear AL	NB. 3 - s is for a VERB
expr comment a,< s,QQ,":N
('*',expr) comment x deflt0 y	NB. >>> UNFINISHED !!!
)

simple=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'simple: ',linear y
if.     AL -: <,BL do.
  if. IsDyad x do. < xX else. < xY end.
elseif. AL -: <,BR do.
  < xY
elseif.do.
NB.   expr comment x deflt0 y	NB. --produces redundant comments.
  x deflt0 y
end.
)

status=: 3 : 0
	NB. output the status of user-alterable nouns for re-input
smoutput '>>> status of tte (re-enter a line to change it)...'
indent=. 5#SP
for_no. ;:'COPULA DECOMPOSE NOCOMMENT PREVERB PREFIX' do.
  nom=. (>no),'_tte_'
  smoutput ; indent ; nom ; '=:' ; TAB ; crex nom~
end.
)

swap=: 4 : 0
'xX xY AL AM AR'=. x Expander y
expr=. 'swap: ',linear y
if. IsNoun AL do.
	('?',expr) comment x deflt0 y
elseif. IsDyad x do.
	assert (xY xmake xX)-: (|.x)	NB. <<<<<<<< REMOVE ONCE CONVINCED
	expr comment (|.x) main AL
elseif. do.
	expr comment (xY xmake xY) main AL
end.
)

toname=: 3 : 0
0 toname y	NB. x=0 - name for a NOUN
:
	NB. y - sentence-list
	NB.	({:y) - last sentence in list
	NB.	(}:y) - residue sentences
	NB. x - x-arg for gensym
	NB. returns: [generated symbol] ; [assignment_to_symbol]
NB. Example:
NB.    toname 't0=: # y' ; '#t0'
NB. ┌──┬───────────────────┐
NB. │z1│┌────────┬────────┐│
NB. │  ││t0=: # y│z1=: #t0││
NB. │  │└────────┴────────┘│
NB. └──┴───────────────────┘
NB. 
if. IsName{:y do.
	NB. Case: last sentence of (y) is bald (<name) ...
	NB. (<name) is stripped off and offered as the "new" symbol.
	NB. This eliminates redundant sentences like: t0=: y
  (>{:y) ,&:< (}:y)
else. 
  s=. x gensym''		NB. make a new symbol: s
  b=.(}:y),(<s,COPULA,SP,>{:y)	NB. augmented sentence-list
  s ,&:< b
end.
)

ttreport_z_=: 3 : 0
	NB. report on failed test
cocurrent 'base'
if. -. LT-:L do.
smoutput '>>> L paren rep of u (5!:6<''u'')'
smoutput L
end.
smoutput '>>> LT paren rep of T (5!:6<''T'')'
smoutput LT
smoutput '>>> LU paren rep of explication U (5!:6<''U'')'
smoutput LU
smoutput '>>> ZU result of running U with [X],Y'
smoutput ZU
smoutput '>>> ZT result of running T with [X],Y'
smoutput ZT
)

vv=: ":@|:@,:

xmake=: 3 : 0
	NB. Makes correct (x) inside an Expander verb
	NB. which is the explicand's args...
	NB. 	x - explicand's x-arg (or '' for a Monad)
	NB. 	y - explicand's y-arg
,<,>y
:
(,<,> x),,<,>y
)

start''
